### K8s to ECS Fargate specification conversion details
The `specctl` script parses Kubernetes objects and extracts attributes needed for related ECS objects. The `*_input.json` file is used to provide additional input that are necessary to run task and services on ECS. Remember when you run containers in ECS Fargate on AWS cloud you need to specify CPU, memory, subnet(s), and IAM. And also some optional but crucial elements such as log groups for container logs. All these additional input are not present in Kubernetes specification and require to be provided through the `*_input.json` file.

Below is a list of Kubernetes objects that are parsed along with details on what attributes are extracted and how those attributes are mapped to ECS objects.
* Kubernetes Deployment object has some attributes that map to ECS service and some that map to ECS task definition object. The deployment related to replica set and settings associated with rolling deployment become part of ECS service definition. For example, `replicas` become `desiredCount`, rolling deployment settings `maxSurge`, `maxUnavailable`become part of ECS service `deploymentConfiguration` mapping to attributes `maximumPercent`, and `minimumHealthyPercent` respectively (with little bit of manipulation). The deployment template part which captures pod and associated container definitions become part of the ECS task definition.

* Kubernetes Service object maps to ECS service. Currently, this script only handles ClusterIP and Load Balanced service type. The ClusterIP service is simply an ECS service with a CloudMap based DNS entry. For example, `my-service.namespace.cluster.local`, will remain same in ECS with `my-service` as the service name and `namespace.cluster.local` as the domain registry in CloudMap. The Kubernetes load balanced service maps to ECS service with an NLB. There one important challenge though. In ECS both the CloudMap registry and ALB/NLB have to be created beforehand and appropriate values have to be provided in ECS service definition. Another important aspect to note is that in Kubernetes pods and services are independent objects. Kubernetes services use label selectors to identify the pods for a specific service. In ECS service, tasks are creaetd as part of service creation. The tasks belong to service and are not independent, so there is no need for label selectors in ECS.

* Kubernetes Pod object maps to ECS task and task definition. Container definitions form the bulk of pod specification. Kubernetes and ECS have equivalent attributes for most of the container definition needs such as volumes, environment variables, ports.

* Kubernetes ConfigMap object maps to AWS SSM Parameter. Just like Kubernetes pods can access the ConfigMap parameters and values, ECS tasks can also access parameters from SSM Parameter Store. The important difference is that the SSM Parameters have to be created separately and the parameter name has to be supplied in ECS task container definitions.

* Kubernetes Secrets object maps to AWS SSM Parameter Store or AWS Secrets Manager. Just like Kubernetes pods can access the secrets during runtime, ECS tasks can also access secrets from Parameter Store or Secrets Manager securely during runtime. Again the important difference is that secrets need to be stored in either SSM Parameter Store or Secrets Manager and the parameter name/ARN has to be made available in container definition.

